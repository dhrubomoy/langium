/******************************************************************************
 * Copyright 2024 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Maps `(parentNodeType, fieldName)` pairs to child node type names.
 * Generated alongside the Lezer grammar by `LezerGrammarTranslator`.
 *
 * Used by `LezerSyntaxNode.childForField()` / `childrenForField()` to recover
 * Langium field names from the Lezer parse tree, since Lezer's tree nodes don't
 * carry assignment information directly.
 *
 * Example: For Langium rule `Person: 'person' name=ID age=INT?;`
 * the field map contains:
 * - `("Person", "name") → ["PersonName"]`
 * - `("Person", "age") → ["PersonAge"]`
 *
 * Where `PersonName` and `PersonAge` are wrapper nonterminals generated by the translator.
 */
export interface FieldMap {
    /** Get the child node type(s) that represent a field on a parent rule. */
    getChildTypes(parentType: string, fieldName: string): string[] | undefined;
    /** Get the field name for a child node type within a parent. */
    getFieldName(parentType: string, childType: string): string | undefined;
}

/**
 * Raw JSON format for serialized field maps.
 * Maps `parentType → { fieldName → childType[] }`.
 */
export interface FieldMapData {
    readonly [parentType: string]: {
        readonly [fieldName: string]: readonly string[];
    };
}

/**
 * Default implementation of FieldMap backed by a JSON data structure.
 */
export class DefaultFieldMap implements FieldMap {
    /** Forward map: `parentType → fieldName → childType[]` */
    private readonly forwardMap: Map<string, Map<string, string[]>>;
    /** Reverse map: `parentType → childType → fieldName` */
    private readonly reverseMap: Map<string, Map<string, string>>;

    constructor(data: FieldMapData) {
        this.forwardMap = new Map();
        this.reverseMap = new Map();

        for (const [parentType, fields] of Object.entries(data)) {
            const fieldEntries = new Map<string, string[]>();
            const reverseEntries = new Map<string, string>();

            for (const [fieldName, childTypes] of Object.entries(fields)) {
                fieldEntries.set(fieldName, [...childTypes]);
                for (const childType of childTypes) {
                    reverseEntries.set(childType, fieldName);
                }
            }

            this.forwardMap.set(parentType, fieldEntries);
            this.reverseMap.set(parentType, reverseEntries);
        }
    }

    getChildTypes(parentType: string, fieldName: string): string[] | undefined {
        return this.forwardMap.get(parentType)?.get(fieldName);
    }

    getFieldName(parentType: string, childType: string): string | undefined {
        return this.reverseMap.get(parentType)?.get(childType);
    }
}

/**
 * An empty field map that always returns undefined.
 * Used as a fallback when no field map data is available.
 */
export const EMPTY_FIELD_MAP: FieldMap = {
    getChildTypes: () => undefined,
    getFieldName: () => undefined,
};
